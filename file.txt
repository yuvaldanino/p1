void parseCommand(char *cmd, struct Command *command) {
    char *nl = strchr(cmd, '\n');
    if (nl) {
        *nl = '\0';
    }

    // array to store segment s
    char *segments[MAX_ARGS]; 
    int numSegments = 0;



    //occurance of | gets first seg before pipe
    char *pipeSegment = strtok(cmd, "|");
    printf("Processing segment: '%s'\n", pipeSegment);
    while (pipeSegment != NULL && numSegments < MAX_ARGS) {
        segments[numSegments++] = pipeSegment;
        pipeSegment = strtok(NULL, "|");
    }

    for (int i = 0; i < numSegments; i++) {
        command->argc = 0;
        command->redirect = 0;
        command->outfile = NULL;
        command->next = NULL;
    
    
    
    }



    //stores parsed info of first cmd 
    struct Command *currentCmd = command;


        // loop that keep runnig as long as we have pipes 
        while(pipeSegment != NULL){
                //intializee Command 
                currentCmd->argc = 0;
                currentCmd->redirect = 0;
                currentCmd->outfile = NULL;
                currentCmd->next = NULL;


                //check for redirects 
                char *redirectSymb = strchr(pipeSegment, '>');
                // if we have redirecy symbol
                if(redirectSymb){
                        //idea: split at redirect, assign command-> outfile and deleted spaces 

                        //point to > and swictch it to null terminator
                        *redirectSymb = '\0';

                        //assign command-> file to actual file which is 1 over > location 
                        currentCmd->outfile = redirectSymb + 1;

                        // indicate a redirect occured 
                        currentCmd->redirect = 1;

                        //to handel weird spaces moves file pointer after spaces 
                        while(*currentCmd->outfile == ' '){
                                currentCmd->outfile++;
                        }


                        //printf("file: %s ", command->outfile);

                }

                 // Print redirection information, if any
                if (currentCmd->redirect) {
                        printf("Redirect to: '%s'\n", currentCmd->outfile);
                }
                
                char *token = strtok(cmd, " ");
                while (token != NULL && currentCmd->argc < MAX_ARGS) {
                        currentCmd->argv[currentCmd->argc] = token;
                        
                        // Print each argument for debugging
                        //printf("Argument[%d]: %s\n", command->argc, command->argv[command->argc]);

                        currentCmd->argc++;
                        
                        token = strtok(NULL, " ");
                }
                currentCmd->argv[currentCmd->argc] = NULL;


                //check to see if there is another pipe seg
                pipeSegment = strtok(NULL, "|");
                printf("Processing next segment: '%s'\n", pipeSegment);

                // if there no more deg ( pipeSef is NULL)
                if(!pipeSegment){
                        //break loop beacuse we only need to run this many commands 
                        printf("no pipes");

                        break;
                }
                // Print a marker for a pipeline
                printf("Pipeline to next command\n");

                //if there is still another pipe
                // update curr pipe  to prepare for next pipe
                //allocate  mem for new command to store next seg info
                currentCmd->next = (struct Command *)malloc(sizeof(struct Command));
                currentCmd = currentCmd->next;

        }       
    

}











//stores parsed info of first cmd 
    struct Command *currentCmd = command;


        // loop that keep runnig as long as we have pipes 
        while(pipeSegment != NULL){
                //intializee Command 
                currentCmd->argc = 0;
                currentCmd->redirect = 0;
                currentCmd->outfile = NULL;
                currentCmd->next = NULL;


                //check for redirects 
                char *redirectSymb = strchr(pipeSegment, '>');
                // if we have redirecy symbol
                if(redirectSymb){
                        //idea: split at redirect, assign command-> outfile and deleted spaces 

                        //point to > and swictch it to null terminator
                        *redirectSymb = '\0';

                        //assign command-> file to actual file which is 1 over > location 
                        currentCmd->outfile = redirectSymb + 1;

                        // indicate a redirect occured 
                        currentCmd->redirect = 1;

                        //to handel weird spaces moves file pointer after spaces 
                        while(*currentCmd->outfile == ' '){
                                currentCmd->outfile++;
                        }


                        //printf("file: %s ", command->outfile);

                }

                 // Print redirection information, if any
                if (currentCmd->redirect) {
                        printf("Redirect to: '%s'\n", currentCmd->outfile);
                }
                
                char *token = strtok(cmd, " ");
                while (token != NULL && currentCmd->argc < MAX_ARGS) {
                        currentCmd->argv[currentCmd->argc] = token;
                        
                        // Print each argument for debugging
                        //printf("Argument[%d]: %s\n", command->argc, command->argv[command->argc]);

                        currentCmd->argc++;
                        
                        token = strtok(NULL, " ");
                }
                currentCmd->argv[currentCmd->argc] = NULL;


                //check to see if there is another pipe seg
                pipeSegment = strtok(NULL, "|");
                printf("Processing next segment: '%s'\n", pipeSegment);

                // if there no more deg ( pipeSef is NULL)
                if(!pipeSegment){
                        //break loop beacuse we only need to run this many commands 
                        printf("no pipes");

                        break;
                }
                // Print a marker for a pipeline
                printf("Pipeline to next command\n");

                //if there is still another pipe
                // update curr pipe  to prepare for next pipe
                //allocate  mem for new command to store next seg info
                currentCmd->next = (struct Command *)malloc(sizeof(struct Command));
                currentCmd = currentCmd->next;

        }  











        #include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h> // For PATH_MAX
#include <fcntl.h>


#define CMDLINE_MAX 512
#define MAX_ARGS 10


//include for syscall functions 
#include <sys/types.h>
#include <sys/wait.h>

struct Command{
        char *argv[MAX_ARGS];
        int argc; 

        // output file for redirection 
        char *outfile;  
        // Flag if redirect is needed 
        int redirect;   
        // pointer to next cmd in pipeline 
        struct Command *next; 
};


void parseCommand(char *cmd, struct Command *command) {
    char *nl = strchr(cmd, '\n');
    if (nl) {
        *nl = '\0';
    }

    // array to store segment s
    char *segments[MAX_ARGS]; 
    int numSegments = 0;



    //occurance of | gets first seg before pipe
    char *pipeSegment = strtok(cmd, "|");
    printf("Processing segment: '%s'\n", pipeSegment);
    while (pipeSegment != NULL && numSegments < MAX_ARGS) {
        segments[numSegments++] = pipeSegment;
        pipeSegment = strtok(NULL, "|");
    }
    
    struct Command *currentCmd = command;

    for (int i = 0; i < numSegments; i++) {
        currentCmd->argc = 0;
        currentCmd->redirect = 0;
        currentCmd->outfile = NULL;
        currentCmd->next = NULL;
        
        char *segment = segments[i];

        //check for redirects 
                char *redirectSymb = strchr(pipeSegment, '>');
                // if we have redirecy symbol
                if(redirectSymb){
                        //idea: split at redirect, assign command-> outfile and deleted spaces 

                        //point to > and swictch it to null terminator
                        *redirectSymb = '\0';

                        //assign command-> file to actual file which is 1 over > location 
                        currentCmd->outfile = redirectSymb + 1;

                        // indicate a redirect occured 
                        currentCmd->redirect = 1;

                        //to handel weird spaces moves file pointer after spaces 
                        while(*currentCmd->outfile == ' '){
                                currentCmd->outfile++;
                        }


                        //printf("file: %s ", command->outfile);

                }

                // Print redirection information, if any
                if (currentCmd->redirect) {
                        printf("Redirect to: '%s'\n", currentCmd->outfile);
                }
                
                char *token = strtok(cmd, " ");
                while (token != NULL && currentCmd->argc < MAX_ARGS) {
                        currentCmd->argv[currentCmd->argc] = token;
                        
                        // Print each argument for debugging
                        //printf("Argument[%d]: %s\n", command->argc, command->argv[command->argc]);

                        currentCmd->argc++;
                        
                        token = strtok(NULL, " ");
                }
                currentCmd->argv[currentCmd->argc] = NULL;

                // Debug print
                printf("Command %d: ", i + 1);
                for (int j = 0; j < currentCmd->argc; j++) {
                        printf("%s ", currentCmd->argv[j]);
                }
                printf("\n");

                if (i < numSegments - 1) {
                        currentCmd->next = (struct Command *)malloc(sizeof(struct Command));
                        currentCmd = currentCmd->next;
                }
    
    
    }


         
    

}

void executeCommand(struct Command *command) {
        // for wait 
        int status;
        pid_t pid;

        pid = fork();

        if(pid == -1){
                perror("fork");
                exit(1);
        }else if (pid > 0){  // parents
                waitpid(pid,&status, 0); 
                //fprintf(stdout, "Return status value for '%s': %d\n",command->argv[0], WEXITSTATUS(status));
        }else {    // pid is 0 -> child 
                
                // checking statement to ensure reading right arguments 
                //fprintf(stdout, "Argument is '%s'\n",command->argv[0]);
               
                //execvp -> number of arguments is not known 
                execvp(command->argv[0], command->argv);

                // if fails and doesnt execute 
                perror("execvp");
                exit(EXIT_FAILURE);
        } 


}

void handleBuiltInCommands(struct Command *command, int *shouldContinue) {
        
        //error wrong size
        if(command->argc <= 0){
                perror("no arguments");
                exit(1);               
        }

        if (strcmp(command->argv[0], "exit") == 0){
                
                fprintf(stderr, "Bye...\n");
                *shouldContinue = 0; 

        }else if(strcmp(command->argv[0], "pwd") == 0){
                //pwd
                // declare char for max path size 
                char cwd[PATH_MAX];

                //checks if there exists a path 
                if( getcwd(cwd, sizeof(cwd)) != NULL ){
                        //prints cwd if not NULL
                        printf("%s\n", cwd);   
                }else{
                        perror("getcwd error");
                
                }

        }else if(strcmp(command->argv[0], "cd") == 0){
                // cd

                // ensure cd has argument 
                if(command->argc > 1){
                        //chdir returns 0 if worked correctly, error for other values 
                        //changes direcory 
                      if(chdir(command-> argv[1]) != 0 ){
                        // if error chdir
                        perror("chdir");
                      }  
                }else{
                        // no arguments for cd 
                      fprintf(stderr, "cd: missing argument\n");  
                }
        }
}

void handleRedirection(struct Command *command, int *std_out){

        //open file 
        int fd = open(command->outfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);

        //file no open 
        if (fd == -1){
                perror("open");
                exit(EXIT_FAILURE);  
        }

        //in order to restore stdout -> save where stdout is directed to 
        // dup = duplicate 
        *std_out = dup(STDOUT_FILENO);\
        //if no location (error)
        if(*std_out == -1){
                perror("dup");
                close(fd);
                exit(EXIT_FAILURE);    
        }

        // do redirection 
        //if error report error 
        if ( dup2(fd, STDOUT_FILENO) == -1){
                perror("dup2");
                close(fd);
                exit(EXIT_FAILURE);    
        }

        close(fd);

}

void restoreSTDOUT(int std_out){
        //stdout to original file descriptor 
        dup2(std_out, STDOUT_FILENO);
        close(std_out);
}



int main(void){
        char cmd[CMDLINE_MAX]; 
        struct Command command;
        int keepGoing = 1;

        while (keepGoing) {

                /* Print prompt */
                printf("sshell$ ");
                fflush(stdout);  // flushes STDout so it prints instantly 

                // error 
                if (!fgets(cmd, CMDLINE_MAX, stdin)) {
                        perror("fgets");
                        continue;
                }

                // parse the command line 
                parseCommand(cmd, &command);

                //check if we need redirection 

                // handle the built in commands exit, pwd, cd 
                handleBuiltInCommands(&command, &keepGoing);

                

                // execute commands 
                if (keepGoing){
                        
                        if(command.next != NULL){
                                //executePipeline(&command);
                        
                        // if a redirect flag was signaled
                        }else if(command.redirect){
                                //save orignal stdout destination 
                                int std_out;
                                // handles the redirction
                                handleRedirection(&command, &std_out);
                                // does command with the new redirect 
                                executeCommand(&command);
                                //change stdout back to terminal (or original directed location (std_out))
                                restoreSTDOUT(std_out);
                        }else{
                                executeCommand(&command);
                        }
                        
                }
                
                
        }

        return EXIT_SUCCESS;
}



/* Get command line */
                //fgets(cmd, CMDLINE_MAX, stdin);

                /* Print command line if stdin is not provided by terminal */
                /*if (!isatty(STDIN_FILENO)) {
                        printf("%s", cmd);
                        fflush(stdout);
                }*/

                /* Regular command */
                //retval = system(cmd);
                //fprintf(stdout, "Return status value for '%s': %d\n",
                        //cmd, retval);